import re

######################################## SYMBOLS СПЕЦИАЛЬНЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ ##################################
###################################################################################
###################################################################################

######################################## \d any decimal digit ##################################

# Это регулярное выражение ищет одну или более цифр (\d — это цифра, а + означает "один или более").
# \d+: Находит последовательности цифр, такие как "01", "02", "1".

# text = "Simple text 01 to test 02 regex 1, 20233"
# print(re.findall('\d+', text)) # если без + то получим каждый числовой символ оттдельно # ['0', '1', '0', '2', '1']

######################################## \D any non Decimal character ##################################

# text = "Simple text 01 to test 02 regex 1, 20233"
# print(re.findall('\D', text)) ## Усі символи які є не числами, включно зі пробілами та нішим  - ['S', 'i', 'm', 'p', 'l', 'e', ' ', 't', 'e', 'x', 't', ' ', ' ', 't', 'o', ' ', 't', 'e', 's', 't', ' ', ' ', 'r', 'e', 'g', 'e', 'x', ' ', ',', ' ']
# print(re.findall('\D+', text)) ## (Послідовність символів) Якщо додати плюс то будуть виведені повні слова, що розділені пробілами -- ['Simple text ', ' to test ', ' regex ', ', ']

######################################## \s WHITESPACE ##################################

# text = "Simple text to test regex"
# print(re.findall('\s', text))
#
# text = "Simple 02 text to test 02 regex"
# print(re.findall('\s+', text)) # Буде знаходити усі пробіли, що йдуть один за одним

# text = "Simple 01 text to 02 test regex03"
# print(re.findall('\s', text)) # [' ', ' ', ' ', ' ', ' ', ' '] - знаходимо 6 пропусків

# text = "Simple 01 text to 02 test regex03"
# print(re.findall('\s\d+', text)) # ПАТЕРН який знаходить сходження де спочітку йде пробіл й далі всі числові знаки [' 01', ' 02']

# text = "Simple 01 text to 02 test regex03"
# print(re.findall('\s\D+', text)) # [' text to ', ' test regex'] Початок - пробіл, а після пробілу будь-який символ окрім цифри

######################################## \S any non whitspace character (УСЕ ЩО НЕ Є ПРОБІЛОМ, включно зі буквами, буквально усе)##################################

# text = "Simple, : !,  01 text to 02 test :..: regex03"
# print(re.findall('\S', text))

# text = "Simple, : !,  01 text to 02 test :..: regex03"
# print(re.findall('\S+', text)) # ['Simple', '01', 'text', 'to', '02', 'test', 'regex03']

######################################## \w alpha numeric characters + underscore ##################################

# text = "Simple, 01 text to 02 test_ ________________ _regex03 #%%% &&&??? ?"
# print(re.findall('\w', text))
#
# text = "Simple, 01 text to 02 test_ _________________ _regex03"
# print(re.findall('\w+', text)) # ['Simple', '01', 'text', 'to', '02', 'test_', '_________________', '_regex03']
#
#
# text = "Simple, 01 text to 02 test_ _________df_______dasf_ _regex03"
# print(re.findall('\w+', text))

######################################## \W non alpha numeric characters + non underscore ##################################

# text = "Simple, 01 text to 02 test_ ________________ _regex03 #%%% &&&??? ?"
# print(re.findall('\W', text))
#
# text = "Simple, 01 text to 02 test_ _________________ _regex03"
# print(re.findall('\W+', text))
#
# text = "Simple, 01 text to 02 test_ _________df_______dasf_ _regex03"
# print(re.findall('\W+', text))

######################################## МЕТА  СИМВОЛЫ  ##################################
#################################################################################################################
#################################################################################################################

######################################## {m} - m copies of re ##################################

# text = "Simple  text to test regex"
# print(re.findall('\s{2}\S+', text)) # ФІГУРНІ ДУЖКИ ДАЮТЬ ВКАЗАТИ СКІЛЬКИ РАЗІВ МАЄ ПОТОВРЮВАТИСЬ СИМВОЛ або КОМБЫНАЦЫЯ СИМОВЛЫВ ЯКЫ СТОЯТЬ
# ПЕРЕД ВЫДКРИТТЯ ЦИХ ФІГУРНИХ ДУЖОК
# Пример Ищет и выводит все последовательности символов, которые начинаются с двух пробелов (\s{2}) и затем содержат один или более непробельных символов (\S+), в нашем случае
# это только один вариант - первое слово текст, поскольку перед ним 2 пробела

# text = "Simple  text to test regex"
# print(re.findall('\s{2}', text)) # - ['  '] когда всего один раз по два пробела, то находим один обьект

# text = "Simple    text to test regex"
# print(re.findall('\s{2}', text)) # ['  ', '  '] результат когда всего 4 пробела то мы находим два соответцсвия

######################################## {m, n} - from m to n copies of re ##################################

# text = "Simple  text to test regex"
# print(re.findall('\s{1,2}', text)) # знаходимо частини тексту де є пробіліи від одного пробілу до двх пробілів.
#
# text = "Simple___text_to_test_regex___ ____" # чотири аденрскори трфнсформуються в 3 + 1, комбінції будуть ділитися на групи
# print(re.findall('_{1,3}', text))

# text = "Simple__text_to_test_regex___"
# print(re.findall('_{1,2}?', text)) # ['_', '_', '_', '_', '_', '_', '_', '_'] Знак вопроса ? соответствует нулю или одному вхождению оставшегося шаблона.
#

# Ищет и выводит все вхождения символа подчёркивания (_), которые встречаются один или два раза подряд.
# {1,2} — диапазон количества вхождений (1 или 2).
# ? — делает поиск "ленивым" (жадный поиск будет остановлен при первом совпадении, соответствующем условию).
# Объяснение:
#
# _{1,2} — ищет один или два подряд идущих символа подчёркивания.
# ? — ленивый режим, который останавливается, как только находит минимальное соответствие (1 подчёркивание), а не максимальное.
# Если в строке text нет подчёркиваний, результатом будет пустой список.


######################################## "." - dot any character  ##################################

# text = "Simple text to test regex"
# print(re.findall('Simple.+regex', text)) # --> ['Simple text to test regex']
#
# text = "Simple text to test regex."
# print(re.findall('Simple.+regex\.', text)) # # --> ['Simple text to test regex.']
#
# Ищет и выводит подстроку, которая начинается с "Simple" и заканчивается на "regex", включая все символы между ними.
# Объяснение:
#
# Simple — начало подстроки.
# .+ — любой символ (кроме новой строки) один или более раз (жадный поиск, который захватит всё между "Simple" и "regex").
# regex — конец подстроки.

######################################## "^" - start a string or a new line  ##################################

# text = "This is a teset text\nThis is a second line\n"
# print(re.findall('^This.+$', text)) # []
# print(re.findall('^This.+$', text, flags=re.MULTILINE)) # - ['This is a teset text', 'This is a second line']

# Ищет строки в переменной text, которые начинаются с "This" и заканчиваются любыми символами до конца строки, в режиме многострочного поиска.

# Объяснение:
# ^This — ищет строки, начинающиеся с "This" (символ ^ указывает на начало строки).
# .+ — соответствует любому количеству символов (один или более), кроме символа новой строки.
# $ — указывает на конец строки. - Ищем до конца строки
# flags=re.MULTILINE — позволяет регулярному выражению обрабатывать текст как многострочный, где ^ и $ работают в начале и конце каждой строки, а не всего текста.


############################################ "$" ПОШУК ПО ЗАКІНЧЕННЮ ################################################

# text = "This is a teset text regex"
# print(re.findall('.+regex$', text)) # ['This is a teset text regex']

# text = "This is a teset text regex."
# print(re.findall('.+regex$', text)) # [] - ТОШО У КІНЦІ НЕ RegEx, а крапка


############################################ "*" ANy of numbers ################################################

# text = "This is a teset text regex"
# print(re.findall('te*', text)) # Код re.findall('te*', text) шукає всі входження літери 't', за якою може бути нуль або більше літер 'e'.
# ['t', 'te', 't', 'te', 't']

# text = "This is a teset teeeeeext regex"
# print(re.findall('te*', text)) # ['te', 't', 'teeeeee', 't']

# У регулярних виразах символи `*` (зірочка) і `+` (плюс) мають таке значення:
#
# - **`*` (зірочка)**: означає "нуль або більше входжень" попереднього символу. Наприклад, `te*` знайде:
#   - `'t'` (нуль літер `'e'`)
#   - `'te'` (одна літера `'e'`)
#   - `'tee'` (дві або більше літер `'e'`)
#
# - **`+` (плюс)**: означає "одне або більше входжень" попереднього символу. Наприклад, `te+` знайде:
#   - `'te'` (одна літера `'e'`)
#   - `'tee'` (дві або більше літер `'e'`)
#   - Але не знайде просто `'t'`, оскільки після нього повинна бути принаймні одна `'e'`.
#
# Отже, головна різниця:
# - `*` дозволяє **нуль або більше** повторень.
# - `+` дозволяє **одне або більше** повторень.

############################################ "+" one or more any of numbers ################################################

# text = "This is a test text to t regex"
# print(re.findall('t\S+', text)) # ['test', 'text', 'to']
#
# text = "This is a test text  regex"
# print(re.findall('tes\S+', text)) # ['test']

############################################ "?" 0 or 1 repetition ################################################

# text = "Simple text to drink some tea"
# print(re.findall('te?', text)) # Отже, 'te?' шукає підрядки, які починаються з 't' і мають нуль або одну літеру 'e' після неї.
# ['te', 't', 't', 'te']


############################################ [] set of characters, [aoe], [a-z], [A-Z] ################################################

# text = "Simple text to reset regex"
# print(re.findall('[abcdef]+', text)) # ['e', 'e', 'e', 'e', 'e', 'e']

# text = "Simpleee text to etest regex"
# print(re.findall('[abcdeft]+', text)) # ['eee', 'te', 't', 't', 'ete', 't', 'e', 'e']

# text = "Simpleee text to etest regex"
# print(re.findall('[abcdeft\s]+', text)) # ['eee te', 't t', ' ete', 't ', 'e', 'e']
#Таким чином, регулярний вираз '[abcdeft\s]+' знайде всі послідовності, які складаються з літер 'a', 'b', 'c', 'd', 'e', 'f', 't' і пробілів.


# [abcdef] — це символьний клас, який означає будь-яку з літер: 'a', 'b', 'c', 'd', 'e', або 'f'.
# + — означає "одне або більше входжень" цих літер підряд.
# Отже, вираз шукає всі послідовності з однієї або більше літер, які входять у діапазон 'a'–'f'.

# text = "Simple text to reset regex"
# print(re.findall('[abcdef]+', text))

############################################ [^somechars] - not same chars ################################################

# text = "Simple text to reset regex"
# print(re.findall('[^abcdef]', text)) # ['e', 'e', 'e', 'e', 'e', 'e'] - Шукаємо будь-який символ окрім вказаних

###################################################### "|" - pipe -- OR ################################################

# text = "Simple text to test regex"
# print(re.findall('te[x|s]t', text)) # ['text', 'test']

# te[x|s]t — це вираз, який спробує знайти підрядки, які починаються з 'te', далі має символ,
# який є або 'x', або 's', і закінчується на 't'.

# Правильний регулярний вираз:

# text = "Simple text to test regex"
# print(re.findall('te[xs]t', text))

# text = "Simple te t to test regex"
# print(re.findall('te[\s|s]t', text)) # ['te t', 'test']


###################################################### (...) GROUP PATERN ################################################

# text = "Simple234 tex234t to tes43t regex"
# print(re.findall('(\w+) (\S)', text)) # [('Simple234', 't'), ('ex234t', 't'), ('o', 't'), ('es43t', 'r')]

# Ваш вираз '(\w+) (\S)' шукає послідовності слів, де кожне слово повинно бути після пробілу і
# після нього має бути один не-пробільний символ (який зберігається як друга група).
#
# У вашому регулярному виразі '(\w+) (\S)' є кілька ключових елементів:
#
# (\w+) — це група, яка знаходить один або більше символів (букви, цифри, підкреслення) і зберігає їх у групі. Символи \w відповідають будь-якому "словесному" символу (літери та цифри).
# (\S) — це група, яка знаходить один не-пробільний символ. Символ \S відповідає будь-якому символу, крім пробілів.

###################################################### (...) GROUP PATERN + RE MATCH ################################################

# Функція re.match() шукає відповідність на початку рядка. У вашому випадку вона буде шукати перші два слова у рядку.


# text = "Simple text to test regex"
# print(re.match('(\w+) (\w+)', text).groups()) # ('Simple', 'text')

# re.match('(\w+) (\w+)', text) шукає перші два слова, розділені пробілом, і повертає об'єкт матчінгу.
# Метод .groups() повертає ці дві групи як кортеж.

# text = "Simple text to test regex"
# print(re.match('(\w+) (\w+) (\w+) (\w+)', text).groups()) # ('Simple', 'text', 'to', 'test')


###################################################### РЕГУЛЯРНИЙ ВАРИЗ ДЛЯ ПОШУКУ ДРОБОВИХ ЧИСЛ #####################################

# text = "Text with 2.4, 2.5, 556.0010234weff, drobes Digits"
# print(re.findall('\d+\.\d+', text)) # ['2.4', '2.5', '556.0010234']
#
# text = "Text with 2.4, 2.5, 556.0010234weff, drobes Digits"
# print(re.findall('\d+\.\d{3}', text)) # ['556.001'] ОКРУГЛИЛИ ДО СОТИХ


############################################ Огляд Функції бібліотеки RE #####################################
##############################################################################################################
#############################################################################################################

############################################### FINDALL() #####################################

# txt = "Phone numbers are: +11539393, +3806717191741, +390671791741, 380671791741, 0671791741, 023452623463456345634567"
# uk_phones = re.findall(r'\+380[\d]+|380[\d]+|0\d{9}$', txt)
# print(uk_phones)



############################################### SEARCH() #####################################