##################### MAP #######################

# Повертає об'єкт (ітератор), до якого примінена функція, що передавалась в map
# > def multiply(number):
# > return number * 2
# > lst = [1, 2, 3]
# > for item in map(multiply, lst):
# Эта строка запускает цикл for , который проходит по элементам,
# возвращаемым функцией map().Функция map() применяет функцию multiply
# ко всем элементам списка lst.То есть, map(multiply, lst) возвращает итератор,
# который выдаёт результаты применения функции multiply к каждому элементу списка lst.
# >
# print(item)
# < 2, 4, 6

################ СИНТАКСИС MAP ##################

# map(function, iterable, ...)
#
# function: Функция, которая будет применяться к каждому элементу итерируемого объекта.
# iterable: Итерируемый объект, элементы которого будут переданы функции.
# Можете передать несколько итерируемых объектов, если функция принимает
# несколько аргументов. В этом случае функция будет применяться к элементам всех переданных
# итерируемых объектов поэлементно.
#
# Таким образом, функция map() удобна для применения одной и той же функции ко всем элементам итерируемого объекта
# или ко всем парам элементов из нескольких итерируемых объектов.

################################# REDUCE ###############################

# Приміняє передану функцію до кожного елементу ітератора, при цьому функція має приймати 2 елементи,
# перший з яких це результат попереднього виконання цієї функції, а другий наступний елемент ітератора.

# > Ist = [1, 2, 3]
# > func = lambda a, b: a + b
# > Ist_sum = reduce(func, Ist)
# # результат сума всіх чисел Ist -> 6

############################ MAP EXAMPLES #########################

# def power(number):
#     print(f'Call of the function, argument is {number}')
#     return number ** 2
#
# numbers = [1, 5, 6, 8, 9]
#
# for item in map(power, numbers):
#     print(item)
# print(map(power, numbers)) # ПЕРЕДАЄМО ФУНКЦІЮ У ЯКОСІТ АРГУМЕНТУ ПРОСТО НАДАЮЧИ ЇЇ НАЗВУ
# <map object at 0x000001F8301C1900> - отримуємо обєкт який є ітератором, ітератори можемо передавти в конструкції типу for in


##### ANALOG WITH LAMDA FUNCTION

# for item in map(lambda number: number ** 2, numbers):
#     print(item)

########################  REDUCE EXAMPLES ###############################

# from functools import reduce
#
# def add(number1, number2): # три рази відбувається виклик функціїї
#     print(f'Call of the function, argument1: {number1}, argument2: {number2}')
#     return number1 + number2
#
# numbers = [5, 7, 10, 15]
#
# result = reduce(add, numbers)
# print(result)

##### ANALOG WITH LAMDA FUNCTION

#result = reduce(lambda number1, number2: number1 + number2, numbers)

################### FILTER ############################

# --> ФІЛТРУЄ ЗА ТИМИ ДАНИМИ ЗА ЯКИМИ ФУНКЦИЯ ПОВЕРТАЄ ТРУ (Тобто трушні дані відкидує, а із не трушними працюємо далі)
# Повертає ітератор на відфільтровану колекцію. Фільтрація здійснюється на основі допоміжної функції.
# > Ist = [1, 2, 3, 4, 5, 6] - стоврюємо спсок
# > res = filter(lambda a: a % 2, Ist) --Ю свторюємо функцію, через лямбду, яка приймає в себе один аргумент, та як один
# з аргументів функції фільтер передаємо нашу лямбду, наша лямба перевіряє парне це число чи не парне, якщо чило парне, то
# тобто результатом є тру, то цей обєкт залишеться і для ітерації надсилається інший який не ділиться на 2
# > for item in res:
# > print(item) # 1, 3, 5

data = [1, 2, 3, 4, 5, 6, 7, 8]

def add(number):
    return number % 2

for item in filter(add, data): # ВЕРТАЄ ЛИШЕ ТІ ЕЛЕМЕНТИ ІЗ ПОСЛІДОВНОСТІ DATA ДЛЯ ЯКИХ РЕЗУЛЬТАТ ВИКОНАННЯ ФУНКЦІЇ --
    # -- ADD - БУДЕ ТРУ
    print(item)

##### ANALOG WITH LAMDA FUNCTION

for item in filter(lambda number: number % 2, data):
    print(item)

##############################    ZIP    #############################

# Приймає довільну кількість ітераторів і повертає ітератор на tuple,
# де з'єднує відповідні елементи переданих ітераторів починаючи з першого.
# > Ist1 = [1, 2, 3]
# > Ist2 = [4, 5, 6]
# > for item in zip(Ist1, Ist2):
# > print(item) # (1, 4) (2, 5) (3, 6)

# list1 = [1, 2, 3, 4, 5, 6]
# list2 = [6, 5, 4, 3, 2, 1]
# list3 = [0, 0] # буде лише два резщултати тюрду  оскыльки у нас тут лише 2 знаячення
# for item in zip(list1, list2, list3, list1): #можна передавати безліч аргументів
#     print(item)


#############################    SORTED    #############################
#Повертає відсортований list для переданого об'єкту-ітератору

numbers = (0, 5, 1, 6, 2, 10, 3)
sorted_numbers = sorted(numbers) # ОТРИМАЄМО ЛІСТЬ У ЯКОМУ СІ ЕЛЕМЕНТИ ВІДСОРОТОВАНІ В ПОРЯДКУ ЗРОСТАННЯ
print(sorted_numbers)

sorted_numbers_reverse = sorted(numbers, reverse=True) - У зворотньому порядку порядку
print(sorted_numbers_reverse)