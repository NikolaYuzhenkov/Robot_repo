# code reading, сверху вниз

#print(i)
#i = 1 #name 'i' is not defined. Did you mean: 'id'?

#========================================================#

#coments
#print(i)
#i = 1 #name 'i' is not defined. Did you mean: 'id'?

#========================================================#

# naming

#i =1
#my_variable = 2
#etc = 34

#========================================================#

# create a variable

#new_my_variable = 44

#========================================================#

# change variable

my_variable = 2

my_variable += 44

my_variable -= 44

my_variable **= 2

print(my_variable)

#========================================================#

# operators

#number = 2
#print(number + 2)
#print(number - 2)
#print(number * 2)
#print(number / 2)
#print(number // 2)
#print(number % 2)
#print(number ** 2)

#number += 2
#number -= 2
#number *= 2
#number /= 2
#number //= 2
#number %= 2
#number **= 2
#print(number)
#========================================================#

# type casting

num = 1 # - все, что не ноль это True
print(bool(num))

num_2 = 0 # - ноль - всегда False
print(bool(num_2))

string = 'test' #- текст это тоже один - True
print(bool(string))

string_2 = '' # текст - остутсвие текста - ноль False
print(bool(string_2))

#========================================================#

# type() function

#n = 1
#print(n)
#print(type(n))

# = 2.0
#print(type(n))

#n = '2.0'
#print(type(n))

#========================================================#

#Python Variables Are Pointers
x  =  10
y  =  x
x  +=  5   # додати 5 до значення x і призначити його x
print ( "x =" ,  x )
print ( "y =" ,  y )

#У Python змінні працюють за зміною посилань на об'єкти.
#У вашому коді, коли ви пишете `y = x`, ви не створюєте новий об'єкт для y,
#а лише створюєте посилання `y`, яке вказує на той самий об'єкт, на який вказує `x`.
#Таким чином, обидві змінні посилаються на один і той самий об'єкт у пам'яті.
#Коли ви пізніше змінюєте значення `x` на `x += 5`, ви фактично змінюєте об('єкт, на який посилається `x`,
#додаючи 5 до його поточного значення (10 + 5 = 15).
#Однак змінна `y` все ще посилається на той самий об')єкт, який був створений на початку, тому значення `y` залишається 10.
#Таким чином, коли ви виводите значення `x` та `y`, ви бачите, що `x` змінилося на 15 (10 + 5), а `y` залишається 10, оскільки він посилається на оригінальний об('єкт, '
#на який вказувало `x` на момент створення `y`.)

#========================================================#

x  =  [ 1 ,  2 ,  3 ]
y  =  x
print(y)
x . append ( 4 )
print ( y ) # у такому випадку зміни прводились на самим обєктом даних, а не стоврювався новий, саме тому зміни будуть відоброження й в "y" НИЖЧЕ ПОЯСНЕННЯ:

#У першому випадку, коли ви присвоюєте `y = x`, ви створюєте посилання `y`, яке вказує на той самий об'єкт, на який вказує `x`.
# У цьому випадку, коли ви змінюєте значення `x` за допомогою `x += 5`, ви фактично створюєте новий об'єкт для `x` (число 15),
# але `y` залишається посиланням на оригінальний об'єкт (число 10), тому воно не змінюється.
# У другому випадку, коли ви робите `y = x`, ви також створюєте посилання `y`, яке вказує на той самий об'єкт, на який вказує `x`.
# Проте, коли ви виконуєте `x.append(4)`, ви змінюєте сам об'єкт, на який вказують обидві змінні `x` і `y`.
# Таким чином, зміни, які ви робите до об'єкту, змінюються у всіх змінних, які посилаються на цей об'єкт.
# Отже, якщо ви виведете значення `y` після зміни `x`, ви побачите, що `y` також змінилося.

x  =  [ 1 ,  2 ,  3 ] #мутабельный тип данных
y  =  x
x = [ 1 ,  2 ,  3,  4,  5 ]
print(y) # теперь

#========================================================#

text = 'ass' #- иммутабельный
text1 = text
text = text1 + text
print(text1)
