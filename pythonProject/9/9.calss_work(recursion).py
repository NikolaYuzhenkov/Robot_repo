# Рекурсія у програмуванні це, простими словами, виклик функції із цієї ж функції.
# Кількість викликів функції при цьому називається глибиною рекурсії. В Python стандартна глибина рекурсії складає 1000 викликів, але може бути змінена.
# > def my_func():
#     my_func()
# Це поганий приклад рекурсії, оскільки така функція буде постійно викликати себе і якщо її запустити в Python, то отримаємо помилку RecursionError:
# maximum recursion depth exceeded.

# Одним із найпростіших прикладів для зображення рекурсії може бути задача із обрахунку факторіала числа.
# Факторіал числа п добуток натуральних чисел від одиниці до п включно, позначається n!.
# --->>> В цьому прикладі функція рекурсивно обраховує факторіал числа п, викликаючи себе ж, тільки передаючи з кожним разом значення п на 1 менше.
#
# --->>> Коли п дорівнює 0 повертається значення 1 вже без виклику функції і починається вихід з рекурсії.
#
# --->>>Кожен попередній виклик по черзі отримує значення, виконує дію і передає значення далі.
def factorial(n):
    if n == 0:
        return 1
    return n factorial(n-1)
# >>>factorial(10)
# 3628800
# >>> factorial(2)
# 2
# >>> factorial(3)
# 6

# def factorial(n):
#     if n == 0:
#         return 1
#     return n * factorial(n - 1)
#
# print(factorial(4))

# def recursion(n):
#      print(f'Function with {n} value called')
#      if n == 0:
#          return 0
#      recursion(n - 1)
#      print(f'Function with {n} ended')
#
# recursion(5)

# def power(num, p):
#     if p == 0:
#         return 1
#     return num * power(num, p - 1)
#
# result = power(5, 3)
# print(result)

################### ХВОСТОВА РЕКУРСІЯ ################`

Хвостова рекурсія це вид рекурсії, в якій рекурсивний виклик функції є останнім, що виконується в функції.
Щоб зрозуміти це краще, перетворимо рекурсію factorial в хвостову:
← Якщо до цього функція повертала результат множення п на значення рекурсивного виклику, то в хвостовій
рекурсії повертається тільки рекурсивний виклик функції.
>>> def factorial (n, result=1):
if n == 0:
return result
return factorial(n 1, n * result)
>>> factorial(3)
6
Основне, що слід пам('ятати: хоч більшість мов підтримують оптимізацію хвостової рекурсії на рівні компілятора, '
'Python не має такої оптимізації, тому в багатьох моментах краще відмовитися від використання '
'хвостової рекурсії на користь ітеративної реалізації алгоритму.)